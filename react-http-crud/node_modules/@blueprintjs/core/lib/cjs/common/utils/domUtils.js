"use strict";
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFocusableElements = exports.clickElementOnKeyPress = exports.throttle = exports.throttleReactEventCallback = exports.throttleEvent = exports.getActiveElement = exports.elementIsTextInput = exports.elementIsOrContains = exports.hasDOMEnvironment = void 0;
var tslib_1 = require("tslib");
/** @returns true if React is running in a client environment, and false if it's in a server */
function hasDOMEnvironment() {
    return typeof window !== "undefined" && window.document != null;
}
exports.hasDOMEnvironment = hasDOMEnvironment;
function elementIsOrContains(element, testElement) {
    return element === testElement || element.contains(testElement);
}
exports.elementIsOrContains = elementIsOrContains;
/**
 * Checks whether the given element is inside something that looks like a text input.
 * This is particularly useful to determine if a keyboard event inside this element should take priority over hotkey
 * bindings / keyboard shortcut handlers.
 *
 * @returns true if the element is inside a text input
 */
function elementIsTextInput(elem) {
    // we check these cases for unit testing, but this should not happen
    // during normal operation
    if (elem == null || elem.closest == null) {
        return false;
    }
    var editable = elem.closest("input, textarea, [contenteditable=true]");
    if (editable == null) {
        return false;
    }
    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior
    if (editable.tagName.toLowerCase() === "input") {
        var inputType = editable.type;
        if (inputType === "checkbox" || inputType === "radio") {
            return false;
        }
    }
    // don't let read-only fields prevent hotkey behavior
    if (editable.readOnly) {
        return false;
    }
    return true;
}
exports.elementIsTextInput = elementIsTextInput;
/**
 * Gets the active element in the document or shadow root (if an element is provided, and it's in the shadow DOM).
 */
function getActiveElement(element, options) {
    var _a;
    var rootNode = ((_a = element === null || element === void 0 ? void 0 : element.getRootNode(options)) !== null && _a !== void 0 ? _a : document);
    var activeElement = rootNode.activeElement;
    return activeElement instanceof HTMLElement ? activeElement : null;
}
exports.getActiveElement = getActiveElement;
/**
 * Throttle an event on an EventTarget by wrapping it in a
 * `requestAnimationFrame` call. Returns the event handler that was bound to
 * given eventName so you can clean up after yourself.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Events/scroll
 */
/* istanbul ignore next */
function throttleEvent(target, eventName, newEventName) {
    var throttledFunc = throttleImpl(function (event) {
        target.dispatchEvent(new CustomEvent(newEventName, event));
    });
    target.addEventListener(eventName, throttledFunc);
    return throttledFunc;
}
exports.throttleEvent = throttleEvent;
/**
 * Throttle a callback by wrapping it in a `requestAnimationFrame` call. Returns
 * the throttled function.
 *
 * @see https://www.html5rocks.com/en/tutorials/speed/animations/
 */
function throttleReactEventCallback(callback, options) {
    if (options === void 0) { options = {}; }
    var throttledFunc = throttleImpl(callback, function (event2) {
        if (options.preventDefault) {
            event2.preventDefault();
        }
    }, 
    // prevent React from reclaiming the event object before we reference it
    function (event2) { return event2.persist(); });
    return throttledFunc;
}
exports.throttleReactEventCallback = throttleReactEventCallback;
/**
 * Throttle a method by wrapping it in a `requestAnimationFrame` call. Returns
 * the throttled function.
 */
/* istanbul ignore next */
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
function throttle(method) {
    return throttleImpl(method);
}
exports.throttle = throttle;
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
function throttleImpl(onAnimationFrameRequested, onBeforeIsRunningCheck, onAfterIsRunningCheck) {
    var isRunning = false;
    var func = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        onBeforeIsRunningCheck === null || onBeforeIsRunningCheck === void 0 ? void 0 : onBeforeIsRunningCheck.apply(void 0, args);
        if (isRunning) {
            return;
        }
        isRunning = true;
        onAfterIsRunningCheck === null || onAfterIsRunningCheck === void 0 ? void 0 : onAfterIsRunningCheck.apply(void 0, args);
        requestAnimationFrame(function () {
            onAnimationFrameRequested.apply(void 0, args);
            isRunning = false;
        });
    };
    return func;
}
function clickElementOnKeyPress(keys) {
    return function (e) {
        if (keys.some(function (key) { return e.key === key; })) {
            // Prevent spacebar from scrolling the page unless we're in a text field
            if (!elementIsTextInput(e.target)) {
                e.preventDefault();
            }
            e.target.dispatchEvent(new MouseEvent("click", tslib_1.__assign(tslib_1.__assign({}, e), { view: undefined })));
        }
    };
}
exports.clickElementOnKeyPress = clickElementOnKeyPress;
/**
 * Selector for all possible focusable items.
 *
 * Derived from this SO question: {@link https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus}
 *
 * Note: Order may not be correct if children elements use tabindex values > 0.
 */
var SELECTOR_FOCUSABLE = [
    'a[href]:not([tabindex="-1"])',
    'button:not([disabled]):not([tabindex="-1"])',
    'details:not([tabindex="-1"])',
    'input:not([disabled]):not([tabindex="-1"])',
    'select:not([disabled]):not([tabindex="-1"])',
    'textarea:not([disabled]):not([tabindex="-1"])',
    '[tabindex]:not([tabindex="-1"])',
].join(",");
/**
 * Gets all focusable elements within the given element.
 *
 * Selector derived from this SO question: {@link https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus}
 *
 * Note: Order may not be correct if children elements use tabindex values > 0.
 *
 * @param {HTMLElement} element - The element to search within.
 * @returns {HTMLElement[]} An array of focusable elements.
 */
function getFocusableElements(element) {
    return Array.from(element.querySelectorAll(SELECTOR_FOCUSABLE));
}
exports.getFocusableElements = getFocusableElements;
//# sourceMappingURL=domUtils.js.map