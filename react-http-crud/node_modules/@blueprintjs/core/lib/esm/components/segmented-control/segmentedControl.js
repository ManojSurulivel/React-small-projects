/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { __assign, __rest } from "tslib";
import classNames from "classnames";
import * as React from "react";
import { Classes, Intent, mergeRefs, Utils } from "../../common";
import { DISPLAYNAME_PREFIX, removeNonHTMLProps, } from "../../common/props";
import { Button } from "../button/buttons";
/**
 * Segmented control component.
 *
 * @see https://blueprintjs.com/docs/#core/components/segmented-control
 */
export var SegmentedControl = React.forwardRef(function (props, ref) {
    var _a;
    var className = props.className, defaultValue = props.defaultValue, fill = props.fill, inline = props.inline, _b = props.intent, intent = _b === void 0 ? Intent.NONE : _b, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    large = props.large, onValueChange = props.onValueChange, options = props.options, _c = props.role, role = _c === void 0 ? "radiogroup" : _c, _d = props.size, size = _d === void 0 ? "medium" : _d, 
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    small = props.small, controlledValue = props.value, htmlProps = __rest(props, ["className", "defaultValue", "fill", "inline", "intent", "large", "onValueChange", "options", "role", "size", "small", "value"]);
    var _e = React.useState(defaultValue), localValue = _e[0], setLocalValue = _e[1];
    var selectedValue = controlledValue !== null && controlledValue !== void 0 ? controlledValue : localValue;
    var outerRef = React.useRef(null);
    var handleOptionClick = React.useCallback(function (newSelectedValue, targetElement) {
        setLocalValue(newSelectedValue);
        onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(newSelectedValue, targetElement);
    }, [onValueChange]);
    var handleKeyDown = React.useCallback(function (e) {
        var _a;
        if (role === "radiogroup" || role === "menu") {
            // in a `radiogroup`, arrow keys select next item, not tab key.
            var direction = Utils.getArrowKeyDirection(e, ["ArrowLeft", "ArrowUp"], ["ArrowRight", "ArrowDown"]);
            var outerElement = outerRef.current;
            if (direction === undefined || !outerElement)
                return;
            var focusedElement = (_a = Utils.getActiveElement(outerElement)) === null || _a === void 0 ? void 0 : _a.closest("button");
            if (!focusedElement)
                return;
            // must rely on DOM state because we have no way of mapping `focusedElement` to a React.JSX.Element
            var enabledOptionElements = Array.from(outerElement.querySelectorAll("button:not(:disabled)"));
            var focusedIndex = enabledOptionElements.indexOf(focusedElement);
            if (focusedIndex < 0)
                return;
            e.preventDefault();
            // auto-wrapping at 0 and `length`
            var newIndex = (focusedIndex + direction + enabledOptionElements.length) % enabledOptionElements.length;
            var newOption = enabledOptionElements[newIndex];
            newOption.click();
            newOption.focus();
        }
    }, [outerRef, role]);
    var classes = classNames(Classes.SEGMENTED_CONTROL, className, (_a = {},
        _a[Classes.FILL] = fill,
        _a[Classes.INLINE] = inline,
        _a));
    var isAnySelected = options.some(function (option) { return selectedValue === option.value; });
    var buttonRole = ({
        /* eslint-disable sort-keys */
        radiogroup: "radio",
        menu: "menuitemradio",
        group: undefined,
        toolbar: undefined,
        /* eslint-enable sort-keys */
    })[role];
    return (React.createElement("div", __assign({}, removeNonHTMLProps(htmlProps), { role: role, onKeyDown: handleKeyDown, className: classes, ref: mergeRefs(ref, outerRef) }), options.map(function (option, index) {
        var isSelected = selectedValue === option.value;
        return (React.createElement(SegmentedControlOption, __assign({}, option, { intent: intent, isSelected: isSelected, key: option.value, 
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            large: large, onClick: handleOptionClick, size: size, 
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            small: small, role: buttonRole }, (role === "radiogroup" || role === "menu"
            ? {
                "aria-checked": isSelected,
                // "roving tabIndex" on a radiogroup: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex
                // `!isAnySelected` accounts for case where no value is currently selected
                // (passed value/defaultValue is not one of the values of the passed options.)
                // In this case, set first item to be tabbable even though it's unselected.
                tabIndex: isSelected || (index === 0 && !isAnySelected) ? 0 : -1,
            }
            : {
                "aria-pressed": isSelected,
            }))));
    })));
});
SegmentedControl.displayName = "".concat(DISPLAYNAME_PREFIX, ".SegmentedControl");
function SegmentedControlOption(_a) {
    var isSelected = _a.isSelected, label = _a.label, onClick = _a.onClick, value = _a.value, buttonProps = __rest(_a, ["isSelected", "label", "onClick", "value"]);
    var handleClick = React.useCallback(function (event) { return onClick === null || onClick === void 0 ? void 0 : onClick(value, event.currentTarget); }, [onClick, value]);
    return (React.createElement(Button, __assign({}, buttonProps, { onClick: handleClick, text: label !== null && label !== void 0 ? label : value, variant: !isSelected ? "minimal" : undefined })));
}
SegmentedControlOption.displayName = "".concat(DISPLAYNAME_PREFIX, ".SegmentedControlOption");
//# sourceMappingURL=segmentedControl.js.map